#!/usr/bin/env python3

import difflib
import math
import os
import signal
import subprocess
import sys
import time



# PROGRAM CONSTANTS
BLU = '\033[94m'
GRN = '\033[92m'
RED = '\033[91m'
BLK = '\033[0m'
MONTHS = [
    'Jan', 'Feb', 'Mar', 'Apr', 'May',
    'Jun', 'Jul', 'Aug',
    'Sep', 'Oct', 'Nov', 'Dec']
FILES_DIR = 'tmp_grader'
INFILE_PRE = 'grader_infile_'
OUTFILE_PRE = 'grader_outfile_'

# OPTIONAL CONSTANTS
MIN_DESCRIPTION_LENGTH = 12
COMMENT_FREQUENCY_THRESH = 3

# SCORE PENALTY CONSTANTS
NO_MAIN = 10
NO_HEADER = 10
NO_DESCRIPT = 5
NO_COMMENTS = 10
WRONG_FNAME = 5
BAD_OUTPUT = 10
WRONG_ANSWER = 20
LATE_PER_DAY = 10
HAS_ERROR = 30



# Returns a standard 60-character divider to print out.
def div():
    return "------------------------------------------------------------"



# Calls the clear screen command.
def cls():
    subprocess.call(["clear"])



# Returns the similarity ratio between two strings.
def str_similarity(one, two):
     return difflib.SequenceMatcher(None, one, two).ratio()



# Prints the list of issues with the program.
def show_issues(issues):
    print()
    print(RED)
    for i in range(len(issues)):
        print("[" + str(i+1) + "] " + issues[i])
    print(BLK + "To remove an issue, type x# where # is the issue number.")



# Adds up the total grade values using the subtractions and additions lists
def compute_grade(subtractions, additions):
    result = 100
    for sub in subtractions:
        result -= sub
    for add in additions:
        result += add
    return max(0, result)



# calls the OS command to copy the given file into the given directory.
def copy_file(src, dest):
    cmd = "cp " + src + " " + dest
    os.system(cmd)



# Executes the program and displays its ouput in Blue.
# Inputs is an optional list of input messages to send through the shell into
# the running program (given by fPath).
def run_prog(fdir, fname, inputs = [], infiles = []):
    print(BLU)
    worked = True
    out = ""
    err = ""
    cur_dir = os.path.dirname(os.path.abspath(__file__))
    # copy input files (if any) to the current grading directory
    for infname in infiles:
        real_name = '_'.join(infname.split('_')[3:])
        copy_file(FILES_DIR + "/" + infname, fdir + "/" + real_name)
    try:
        # open the subprocess and send any/all input to it
        os.chdir(fdir)
        proc = subprocess.Popen(["python3", fname], \
                                stdin=subprocess.PIPE, \
                                stdout=subprocess.PIPE, \
                                stderr=subprocess.PIPE)
        for send in inputs:
            proc.stdin.write(bytes(send + "\n", "ascii"))
        proc.stdin.flush()
        out = str(proc.stdout.read()).replace("\\n", "\n")[2:-1]
        err = str(proc.stderr.read()).replace("\\n", "\n")[2:-1]
        print(out)
        print(RED + err)
        proc.terminate()
    except:
        worked = False
    # change back to base directory and return results
    os.chdir(cur_dir)
    print(BLK, end="")
    return worked, out, err



# Compare two lists of outputs (one given, one expected), and return a grade
# from 0 to 1 based on how close the output is to the expected set. Optional
# answer keywords can also be graded on a 0 or 1 binary scale. 1 is returned
# if no answers are required. The is_file flag switches prints if the output
# is for a file to avoid confusion for the grader.
def compare_outputs(out_lines, expected_lines, answers = [], is_file = False):
    # ignore any empty lines in the lists
    out = list(filter(("").__ne__, out_lines))
    expected = list(filter(("").__ne__, expected_lines))
    
    # convert lists into a single comparable string
    out = ''.join(out)
    expected = ''.join(expected_lines)
    
    # find the similarity value between the actual and expected output
    ratio = str_similarity(out, expected)

    # if there is a big difference in output length, take off more
    big_diff = False
    if abs(len(out) - len(expected)) >= len(expected) / 2:
        big_diff = True

    # compute output grade
    if big_diff:
        ratio -= 0.5
    output_grade = max(0, ratio)
    
    # now also check that all answer keywords are found and are correct
    answer_grader = 0
    num_correct = 0
    for ans in answers:
        if ans in out:
            num_correct += 1
    if len(answers) == num_correct:
        answer_grade = 1

    # if outputs didn't match, tell the grader about it
    keyword = "file" if is_file else "output"
    if out != expected:
        print(RED + "Mismatched line in " + keyword + ": " + BLK \
                  + str(round(ratio*100, 2)) + "% match")
        print("Expected: '" + expected + "'")
        print("     Got: '" + out + "'")
        if big_diff:
            print(RED + "Big output difference detected: " + BLK \
                      + "(-5% more)")
        if num_correct < len(answers[i]):
            print(RED + "Wrong answer detected: " + BLK + "(" \
                      + ', '.join(answers) + " expected).")
    else:
        print(GRN + keyword.capitalize() + " matched (correct)!" + BLK)
    
    return output_grade, answer_grade



# Does a comparison check to see if the files outputted by the program are
# correct. Optionally, provide an "answers" list to check for answer keywords.
def check_output_files(fdir, outfiles, answers = []):
    output_grade = 0
    answers_grade = 0
    for outfname in outfiles:
        real_name = '_'.join(outfname.split('_')[3:])
        fpath = fdir + "/" + real_name
        
        print("Checking file: " + real_name)
        # if file doesn't exist, grade is 0 for this file
        if not os.path.isfile(fpath):
            print(RED + "Expected output file \"" + real_name + \
                        "\" not found." + BLK)
            continue
        
        # read the output file and the expected file into lists
        f_output = open(fdir + "/" + real_name)
        output = f_output.readlines()
        f_output.close()
        f_expected = open(FILES_DIR + "/" + outfname, "r")
        expected = f_expected.readlines()
        f_expected.close()
        
        # compare them and grade by output similarity
        out_grade, ans_grade = compare_outputs(output, expected, answers, \
                                               is_file = True)
        output_grade += out_grade
        answers_grade += ans_grade
    
    return output_grade, answers_grade



# Clean up all of the input and output files placed in the grading directory
# while testing the program.
def clean_io_files(fdir, infiles, outfiles):
    all_files = infiles + outfiles
    for fname in all_files:
        real_name = '_'.join(fname.split('_')[3:])
        fpath = fdir + "/" + real_name
        if os.path.isfile(fpath):
            os.system("rm " + fpath)



# Looks through the given list of files to find the best match to "pyFile".
# Returns:
#   The actual file name, or None if the file doesn't exist.
#   True if the file name was correct, False otherwise.
def find_uploaded_file(pyfile, their_files):
    their_files_lwr = list(map(str.lower, their_files))
    # if file is named correctly and exists, all is good
    if pyfile in their_files:
        return pyfile, True
    # file lowercase (bad)
    if pyfile.lower() in their_files_lwr:
        return pyfile.lower(), False
    # file missing extension (bad)
    elif pyfile[:-3] in their_files:
        return pyfile[:-3], False
    # file missing extension and lowercase (bad)
    elif pyfile[:-3].lower() in their_files_lwr:
        return pyfile[:-3].lower(), False
    # file not found at all, print an error and do a manual check
    else:
        return None, False



# Computes how many days late this file was submitted and returns the
# approximate number of days estimate. Returns 0 if this file was submitted
# on time.
def get_days_late(fpath, due_day, due_month):
    mtime = os.path.getmtime(fpath)
    timestamp = time.ctime(mtime)
    timestamp = timestamp.split(' ')
    month = MONTHS.index(timestamp[1]) + 1
    if timestamp[2] != '':
        day = int(timestamp[2])
    else:
        day = int(timestamp[3])
    if month > due_month or (month == due_month and day > due_day):
        approx = day - due_day
        if month > due_month:
            approx += 30
        return approx
    else:
        return 0



# Grades the student's submission by trying to match the file to their list
# of files in their directory path. This part also recognizes late submissions
# and incorrect file names.
def do_grade(student, pyfile, their_files, student_dir, due_month, due_day, \
             inputs, infiles, outputs, outfiles, answers, freq_comments):
    cls()
    print("STUDENT:", student)

    # keep track of recommended grade and issues with the program
    issues = []
    comments = []
    subtractions = []

    # Try to find the correct file (even if it's mislabeled)
    true_file, correct_name = find_uploaded_file(pyfile, their_files)
    
    # if file was not found, print error and prompt for the file name manually
    if not true_file:
        print(RED + "File not found" + BLK + " for", student)
        print("Here are all of their files:", their_files)
        # ask grader if any of these should be tried... if not, its a 0
        true_file = input("Should I load any of these? > ")
        if not true_file:
            issues.append("No File: 0")
            comments.append("No file.")
            subtractions.append(100)
    # if file was not named correctly, take off points for that
    elif not correct_name:
        print("FILE:", true_file, RED + "(WRONG)" + BLK)
        issues.append("Wrong File Name ["+true_file+"]: -" + str(WRONG_FNAME))
        comments.append("Wrong file name [-" + str(WRONG_FNAME) + "]")
        subtractions.append(WRONG_FNAME)
    # otherwise, everything is fine
    else:
        print("FILE:", pyfile)
    
    # if the file was in fact found, time it, run it, and cat it
    if true_file:
        fdir = student_dir + "/" + student
        fpath = fdir + "/" + true_file
        
        # figure out submission time and deduct points if late
        days_late = get_days_late(fpath, due_day, due_month)
        if days_late > 0:
            penalty = days_late * LATE_PER_DAY
            subtractions.append(penalty)
            if penalty > 100:
                penalty = "0"
            else:
                penalty = "-" + str(penalty)
            # day or days? it matters!
            days = "days"
            if approx == 1:
                days = "day"
            issues.append("Late: " + str(month) + "/" + str(day) + " (due " +\
                          str(due_month) + "/" + str(due_day) + ")" +\
                          " [approx " + str(approx) + " " + days +\
                          " late]: " + penalty)
            comments.append(str(approx) + " " + days + " late ["+penalty+"].")

        # grade flags for trying to run the program
        has_error = False
        output_grade = 0
        answer_grade = 0
        
        # if there is a module, run program with the desired input/output values
        for i in range(len(inputs)):
            print(div())
            print("Testing with input value(s):")
            for j in range(len(inputs[i])):
                print("   " + inputs[i][j])
            matches = 0
            max_matches = len(outputs[i])
            # try to run the program
            worked, out, err = run_prog(fdir, true_file, inputs[i], infiles[i])
            if not worked:
                print(RED + "Program failed to run." + BLK)
                has_error = True
                continue
            if "error" in err.lower():
                print(RED + "Program may have failed to run." + BLK)
                has_error = True
                continue

            # remove empty lines from the output (we will ignore those)
            out = out.split("\n")[:-1]
            out_grade, ans_grade = compare_outputs(out, outputs[i], answers[i])
            output_grade += out_grade
            answer_grade += ans_grade
            
            # look at output files and compare them, and clean up if any
            if len(outfiles[i]) > 0:
                print(div())
                file_grade = check_output_files(fdir, outfiles[i])
                clean_io_files(fdir, infiles[i], outfiles[i])
            
        # compute average grade of output using the sum of all comparisons
        if(len(inputs) > 0):
            output_grade /= len(inputs)
            output_grade = math.floor(output_grade*10) / 10 # round down
            answer_grade /= len(inputs)
        else:
            output_grade = 1
            answer_grade = 1
        print(div())
        print()
        print("Output grade:", output_grade)
        print("Answer grade:", answer_grade)
        print()
        
        # if no module provided, just run the program normally once
        if len(inputs) == 0:
            worked = run_prog(fdir, true_file)
            if not worked:
                print(RED + "Program failed to run." + BLK)
                has_error = True

        # report stats, halt, and then proceed to cat the program
        # TODO - report grade stats
        input("Finished. Press ENTER to continue.")

        # read and print the file, and check it for main(), header, and comments
        f = open(fpath, "r")
        has_main = False
        has_header = False
        at_header = True
        has_description = False
        has_comments = False
        cls()
        print(div())
        for line in f:
            line = line.strip()
            print(line)
            # check for main()
            if not at_header and not has_main and "main" in line:
                has_main = True
            # check for header
            if at_header:
                if len(line) > 0 and line[0] != "#":
                    at_header = False
                if len(line) > 0 and line[0] == "#":
                    has_header = True
            # check for comments
            if not at_header and "#" in line:
                has_comments = True
            # check for program description:
            if at_header and "description" in line.lower():
                wordlen_desc = len("description") + 1
                desc_indx = line.lower().find("description")
                rest = line[(desc_indx + wordlen_desc) : ].strip()
                if len(rest) >= MIN_DESCRIPTION_LENGTH:
                    has_description = True
        f.close()
        print()
        print(div())

        # go through each flag and take off points for it
        if has_error:
            issues.append("Program did not run: -" + str(HAS_ERROR))
            comments.append("Program did not run [-" + str(HAS_ERROR) + "].")
            subtractions.append(HAS_ERROR)
        if answer_grade < 1:
            answer_sub = round(WRONG_ANSWER * (1 - answer_grade))
            issues.append("Wrong answer(s): -" + str(answer_sub))
            comments.append("Wrong answer(s) [-" + str(answer_sub) + "]")
            subtractions.append(answer_sub)
        if output_grade < 1:
            output_sub = round(BAD_OUTPUT * (1 - output_grade))
            issues.append("Mismatched output: -" + str(output_sub))
            comments.append("Mismatched output [-" + str(output_sub) + "]")
            subtractions.append(output_sub)
        if not has_main:
            issues.append("Missing main(): -" + str(NO_MAIN))
            comments.append("Missing main() [-" + str(NO_MAIN) + "].")
            subtractions.append(NO_MAIN)
        if not has_header:
            issues.append("Missing header: -" + str(NO_HEADER))
            comments.append("Missing header [-" + str(NO_HEADER) + "].")
            subtractions.append(NO_HEADER)
        if not has_comments:
            issues.append("No comments: -" + str(NO_COMMENTS))
            comments.append("No comments [-" + str(NO_COMMENTS) + "].")
            subtractions.append(NO_COMMENTS)
        if has_header and not has_description:
            issues.append("Missing or incomplete description: -" + str(NO_DESCRIPT))
            comments.append("Missing description [-" + str(NO_DESCRIPT) + "].")
            subtractions.append(NO_DESCRIPT)

    # Display all issues and the maximum recommended grade, and then let the
    # grader remove issues, and add or subtract points manually, or override
    # the grade as follows:
    #   Let N be a number.
    #       xN      removes issue N
    #       -N      subtracts N points
    #       +N      adds N points
    #       N       overrides the grade to N points
    #               (no input) keeps recommended grade
    show_issues(issues)
    print("Add or subtract points using +N or -N (N is the number of points).")
    recommended = compute_grade(subtractions, [])
    print(GRN + "Max grade: " + str(recommended))
    grade = input(BLU + "Grade:     " + BLK)
    additions = []
    while grade != "":
        modifications = grade.split()
        if(len(modifications) == 1 and modifications[0][0] != "+" \
                                   and modifications[0][0] != "-" \
                                   and modifications[0][0] != "x" \
                                   and modifications[0].isdigit()):
            recommended = int(modifications[0])
            break
        for mod in modifications:
            mod_val = mod[1:]
            if not mod_val.isdigit():
                continue
            if mod[0] == "x":
                issue_indx = int(mod_val) - 1
                issues.pop(issue_indx)
                comments.pop(issue_indx)
                subtractions.pop(issue_indx)
            elif mod[0] == "+":
                c_val = int(mod_val)
                additions.append(c_val)
            elif mod[0] == "-":
                c_val = int(mod_val)
                additions.append(-c_val)
        show_issues(issues)
        recommended = compute_grade(subtractions, additions)
        print(GRN + "New grade: " + str(recommended))
        grade = input(BLU + "Grade:     " + BLK)
    grade = str(max(0, recommended))

    # process standard comments, and get grader append any other notes
    cmnts = ""
    for c in comments:
        cmnts += c + " "
    
    # make suggestions on frequently used comments
    suggestions = []
    for i in range(0, len(freq_comments), 2):
        freq_cment = freq_comments[i]
        freq_count = freq_comments[i+1]
        if freq_count >= COMMENT_FREQUENCY_THRESH:
            suggestions.append(freq_cment)
    if len(suggestions) > 0:
        print()
        print("Frequent comments: use '@#' to enter them " + \
              "(# is the comment number).")
        for i in range(len(suggestions)):
            print("[" + str(i+1) + "] " + "'" + suggestions[i] + "'")
    # get grader to enter his/her own custom comments (optional)
    grader_comment = input(BLU + "Comments:  " + BLK)
    
    # if grader used the '@' to indicate frequent comments, insert them in
    parts = grader_comment.split()
    gcomment_modified = False
    for part in parts:
        if len(part) > 0 and part[0] == "@":
            indx = part[1:]
            if not indx.isdigit():
                continue
            indx = int(indx) - 1
            if indx < len(suggestions):
                grader_comment = grader_comment.replace(part, suggestions[indx])
                gcomment_modified = True
            else:
                grader_comment = grader_comment.replace(part, "")
    
    # add the grader's comments to the string
    cmnts += grader_comment
    
    # if user entered a comment, add it to frequent comments, or increase
    # its frequency if it already exists for future reference
    if grader_comment and not gcomment_modified:
        found_match = False
        for i in range(0, len(freq_comments), 2):
            if str_similarity(grader_comment, freq_comments[i]) >= 0.8 \
               and "@" not in grader_comment:
                freq_comments[i+1] += 1
                found_match = True
                break
        if not found_match and "@" not in grader_comment:
            freq_comments += [grader_comment, 1]

    # set up the user's grade and confirm (or redo) it if grader wants
    usr_grade = []
    usr_grade.append(student)
    usr_grade.append(grade)
    usr_grade.append(cmnts)
    print(usr_grade)
    ans = input("Done. Type 'r' to redo this grade, or 'q' to quit. ")
    quit = False
    if ans.lower() == "r": # redo this grade
        do_grade(student, pyfile, their_files, student_dir, due_month, due_day,\
                 inputs, infiles, outputs, outfiles, answers, freq_comments)
    elif ans.lower() == "q": # quit after writing this grade
        quit = True

    # return the grade for file processing
    print(div() + "\n" + div() + "\n" + div())
    return usr_grade, quit



# remove all grader files from the directory to avoid junk files
def clear_grader_files():
    # TODO - (possibly) make sure we're in the correct directory!
    if os.path.isdir(FILES_DIR):
        os.system("rm -rf " + FILES_DIR)



# Create the files directory. If it already exists, remove it first and then
# create it anew.
def make_temp_dir():
    if os.path.isdir(FILES_DIR):
        clear_grader_files()
    os.mkdir(FILES_DIR)


    
# Opens the given module file (if possible) and reads it to provide a set of
# inputs, outputs, answer keys, and file input/outputs.
def read_module(module):
    inputs = []
    infiles = []
    outputs = []
    outfiles = []
    answers = []
    test_runs = 0
    if module != "":
        # read file and determine number of I/O test runs
        make_temp_dir()
        mod_file = open(module, "r")
        lines = mod_file.readlines()
        mod_file.close()
        test_runs = int(lines[0][4:])
        i = 0
        for run in range(test_runs):
            inputs.append([])
            infiles.append([])
            outputs.append([])
            outfiles.append([])
            answers.append([])
            # ignore any whitespace or invalid/comment lines
            while i < len(lines) and not lines[i].startswith("INPUT"):
                i += 1
            i += 1
            # append each INPUT to the inputs list for this run
            while i < len(lines) and lines[i].startswith(">>>") :
                inputs[run].append(lines[i].strip()[4:])
                i += 1
            # get the INFILES for this run, if any
            while i < len(lines) and lines[i].startswith("INFILE"):
                fname = lines[i].split(' ')[1].strip()
                fname = INFILE_PRE + str(run) + "_" + fname
                infiles[run].append(fname)
                fname = FILES_DIR + "/" + fname
                infile = open(fname, "w")
                i += 1
                while i < len(lines) and lines[i].startswith(">>>"):
                    fline = lines[i].strip()[4:]
                    infile.write(fline + "\n")
                    i += 1
                infile.close()
            # get the expected ANSWERS for this run
            if i < len(lines):
                ans = lines[i].split(' ')
                for j in range(1, len(ans)):
                    answers[run].append(ans[j].strip())
            i += 1
            # get the list of full desired OUTPUTS for this run
            while i < len(lines) and lines[i].startswith(">>>"):
                outputs[run].append(lines[i].strip()[4:])
                i += 1
            # get the OUTFILES for this run, if any
            while i < len(lines) and lines[i].startswith("OUTFILE"):
                fname = lines[i].split(' ')[1].strip()
                fname = OUTFILE_PRE + str(run) + "_" + fname
                outfiles[run].append(fname)
                fname = FILES_DIR + "/" + fname
                outfile = open(fname, "w")
                i += 1
                while i < len(lines) and lines[i].startswith(">>>"):
                    fline = lines[i].strip()[4:]
                    outfile.write(fline + "\n")
                    i += 1
                outfile.close()
    return inputs, infiles, outputs, outfiles, answers



# Go through each student's submission and grade it, then write the grades to
# a file.
def main(assignment, pyfile, due_month, due_day, module, start):
    # set up date, file path, and first person to start grading
    due_month = int(due_month)
    due_day = int(due_day)
    fpath = assignment
    first = True
    go = True
    if start != "":
        go = False
    
    # if a grading module was provided, set it up here:
    inputs, infiles, outputs, outfiles, answers = read_module(module)

    # if the file is non-existent/empty or if user wants to start fresh,
    # we need to write the header of the CSV file again
    out_file = assignment.strip("/") + "_grades.csv"
    ans = "y"
    if os.path.isfile(out_file) and os.stat(out_file).st_size > 0:
        ans = "n"
        ans = input("Grade output file \"" + out_file + \
                    "\" already exists. Overwrite? [Y/n] ")
    if ans.lower() == "y":
        grade_file = open(out_file, "w")
        grade_file.write("\"Last Name\",\"First Name\",\"" + assignment + \
                 "\",\"Feedback to User\"\n")
        grade_file.close()

    # get a sorted list of students and iterate through them
    students = os.listdir(fpath)
    students.sort()
    freq_comments = []
    num_graded = 0
    total_grade = 0
    for student in students:
        # skip students that are before the starting point
        if not go:
            if student.startswith(start):
                go = True
            else:
                continue
        # get the student's submissions and grade the file
        files = os.listdir(fpath + "/" + student)
        usr_grade, quit = do_grade(student, pyfile, files, fpath, \
                                   due_month, due_day, inputs, infiles, \
                                   outputs, outfiles, answers, freq_comments)
        num_graded += 1
        total_grade += int(usr_grade[1])
        
        # write the data to the output file
        student_names = usr_grade[0].split(",")
        if len(student_names) == 2:
            last_name, first_name = student_names
        else:
            last_name = first_name = usr_grade[0]
        grade_file = open(out_file, "a")
        grade_file.write("\"" + last_name + "\",\"" + first_name + "\",\"" +\
                         usr_grade[1] + "\",\"" +\
                         usr_grade[2].replace("\"", "\"\"") + "\"\n")
        grade_file.close()
        if quit:
            break
    print("Session stats:")
    print("   Number of students graded:", num_graded)
    print("   Average grade:", round(total_grade/num_graded, 2))
    
    # clean up any and all grader files
    clear_grader_files()



# interrupt signal function gracefully handles interrupting and exitting
def exit_nicely(signal, frame):
    print("\n")
    print("Quitting! Current student grade has not been saved.\n")
    clear_grader_files()
    exit(0)



# Check parameters and call main() with the appropriate values.
if __name__ == '__main__':
    # set up graceful exit if ctrl-c is pressed
    signal.signal(signal.SIGINT, exit_nicely)
    # process arguments
    if len(sys.argv) < 5:
        print("USAGE: ./grader <assignment> <.py file> <due month> <due day> [--options--]")
        print("Options:")
        print("  -m module  provide a grading module for input/output option checking")
        print("  -s start   provide the first few letters of a last name to start at")
    else:
        # check for options
        module = ""
        start = ""
        remaining_args = sys.argv[5:]
        for i in range(len(remaining_args)):
            if remaining_args[i] == "-m" and len(remaining_args) > i+1:
                module = remaining_args[i+1]
            elif remaining_args[i] == "-s" and len(remaining_args) > i+1:
                start = remaining_args[i+1]
        main(sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4], module, start)