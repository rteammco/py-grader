#!/usr/bin/python3

import sys
import os
import time
import subprocess
import difflib
import math



# PROGRAM CONSTANTS
BLU = '\033[94m'
GRN = '\033[92m'
RED = '\033[91m'
BLK = '\033[0m'
MONTHS = [
    'Jan', 'Feb', 'Mar', 'Apr', 'May',
    'Jun', 'Jul', 'Aug',
    'Sep', 'Oct', 'Nov', 'Dec']

# OPTIONAL CONSTANTS
COMMENT_FREQUENCY_THRESH = 3

# SCORE PENALTY CONSTANTS
NO_MAIN = 10
NO_HEADER = 10
NO_DESCRIPT = 5
NO_COMMENTS = 10
WRONG_FNAME = 5
BAD_OUTPUT = 10
WRONG_ANSWER = 20
LATE_PER_DAY = 10
HAS_ERROR = 30



# Returns a standard 60-character divider to print out.
def div():
    return "------------------------------------------------------------"



# Calls the clear screen command.
def cls():
    subprocess.call(["clear"])



# Returns the similarity ratio between two strings.
def strSimilarity(one, two):
     return difflib.SequenceMatcher(None, one, two).ratio()



# Prints the list of issues with the program.
def showIssues(issues):
    print()
    print(RED)
    for i in range(len(issues)):
        print("[" + str(i+1) + "] " + issues[i])
    print(BLK + "To remove an issue, type x# where # is the issue number.")



# Adds up the total grade values using the subtractions and additions lists
def computeGrade(subtractions, additions):
    result = 100
    for sub in subtractions:
        result -= sub
    for add in additions:
        result += add
    return max(0, result)



# Executes the program and displays its ouput in Blue.
# Inputs is an optional list of input messages to send through the shell into
# the running program (given by fPath).
def runProg(fPath, inputs = []):
    print(BLU)
    worked = True
    out = ""
    err = ""
    try:
        # open the subprocess and send any/all input to it
        proc = subprocess.Popen(["python3", fPath], \
                                stdin=subprocess.PIPE, \
                                stdout=subprocess.PIPE, \
                                stderr=subprocess.PIPE)
        for send in inputs:
            proc.stdin.write(bytes(send + "\n", "ascii"))
        proc.stdin.flush()
        out = str(proc.stdout.read()).replace("\\n", "\n")[2:-1]
        err = str(proc.stderr.read()).replace("\\n", "\n")[2:-1]
        print(out)
        print(RED + err)
        proc.terminate()
    except:
        worked = False
    print(BLK, end="")
    return worked, out, err



# Looks through the given list of files to find the best match to "pyFile".
# Returns:
#   The actual file name, or None if the file doesn't exist.
#   True if the file name was correct, False otherwise.
def findUploadedFile(pyFile, theirFiles):
    theirFilesLwr = list(map(str.lower, theirFiles))
    # if file is named correctly and exists, all is good
    if pyFile in theirFiles:
        return pyFile, True
    # file lowercase (bad)
    if pyFile.lower() in theirFilesLwr:
        return pyFile.lower(), False
    # file missing extension (bad)
    elif pyFile[:-3] in theirFiles:
        return pyFile[:-3], False
    # file missing extension and lowercase (bad)
    elif pyFile[:-3].lower() in theirFilesLwr:
        return pyFile[:-3].lower(), False
    # file not found at all, print an error and do a manual check
    else:
        return None, False



# Computes how many days late this file was submitted and returns the
# approximate number of days estimate. Returns 0 if this file was submitted
# on time.
def getDaysLate(fPath, dueDay, dueMonth):
    mtime = os.path.getmtime(fPath)
    timestamp = time.ctime(mtime)
    timestamp = timestamp.split(' ')
    month = MONTHS.index(timestamp[1]) + 1
    if timestamp[2] != '':
        day = int(timestamp[2])
    else:
        day = int(timestamp[3])
    if month > dueMonth or (month == dueMonth and day > dueDay):
        approx = day - dueDay
        if month > dueMonth:
            approx += 30
        return approx
    else:
        return 0



# Grades the student's submission by trying to match the file to their list
# of files in their directory path. This part also recognizes late submissions
# and incorrect file names.
def doGrade(student, pyFile, theirFiles, path, dueMonth, dueDay, \
            inputs, outputs, answers, frequentComments):
    cls()
    print("STUDENT:", student)

    # keep track of recommended grade and issues with the program
    issues = []
    comments = []
    subtractions = []

    # Try to find the correct file (even if it's mislabeled)
    trueFile, correctName = findUploadedFile(pyFile, theirFiles)
    
    # if file was not found, print error and prompt for the file name manually
    if not trueFile:
        print(RED + "File not found" + BLK + " for", student)
        print("Here are all of their files:", theirFiles)
        # ask grader if any of these should be tried... if not, its a 0
        trueFile = input("Should I load any of these? > ")
        if not trueFile:
            issues.append("No File: 0")
            comments.append("No file.")
            subtractions.append(100)
    # if file was not named correctly, take off points for that
    elif not correctName:
        print("FILE:", trueFile, RED + "(WRONG)" + BLK)
        issues.append("Wrong File Name [" + trueFile + "]: -" + str(WRONG_FNAME))
        comments.append("Wrong file name [-" + str(WRONG_FNAME) + "]")
        subtractions.append(WRONG_FNAME)
    # otherwise, everything is fine
    else:
        print("FILE:", pyFile)
    
    # if the file was in fact found, time it, run it, and cat it
    if trueFile:
        fPath = path + "/" + student + "/" + trueFile
        
        # figure out submission time and deduct points if late
        daysLate = getDaysLate(fPath, dueDay, dueMonth)
        if daysLate > 0:
            penalty = daysLate * LATE_PER_DAY
            subtractions.append(penalty)
            if penalty > 100:
                penalty = "0"
            else:
                penalty = "-" + str(penalty)
            # day or days? it matters!
            days = "days"
            if approx == 1:
                days = "day"
            issues.append("Late: " + str(month) + "/" + str(day) +\
                          " (due " + str(dueMonth) + "/" + str(dueDay) + ")" +\
                          " [approx " + str(approx) + " "+days+" late]: " +\
                          penalty)
            comments.append(str(approx) + " "+days+" late [" + penalty + "].")

        # grade flags for trying to run the program
        has_error = False
        output_grade = 0
        answer_grade = 0
        # if there is a module, run program with the desired input/output values
        for i in range(len(inputs)):
            print(div())
            print("Testing with input value(s):")
            for j in range(len(inputs[i])):
                print("   " + inputs[i][j])
            matches = 0
            max_matches = len(outputs[i])
            # try to run the program
            worked, out, err = runProg(fPath, inputs[i])
            if not worked:
                print(RED + "Program failed to run." + BLK)
                has_error = True
                continue
            if "error" in err.lower():
                print(RED + "Program may have failed to run." + BLK)
                has_error = True
                continue

            # remove empty lines from the output (we will ignore those)
            out = out.split("\n")[:-1]
            real_out = '\n'.join(out)
            out = list(filter(("").__ne__, out))
            # stick expected outputs and actual outputs on one line and compare
            out = ''.join(out)
            expected = ''.join(outputs[i])
            real_expected = '\n'.join(outputs[i])
            ratio = strSimilarity(out, expected)

            # if there is a big difference in output length, take off more
            big_diff = False
            if abs(len(out) - len(expected)) >= len(expected) / 2:
                big_diff = True

            # now also check answers and make sure that (if any) answers are
            # correct - answers are "keywords" in the output that indicate
            # the correct result
            num_correct = 0
            for ans in answers[i]:
                if ans in out:
                    num_correct += 1
            if len(answers[i]) == num_correct:
                answer_grade += 1

            # if outputs didn't match, tell the grader about it
            if out != expected:
                print(RED + "Mismatched line in output: " + BLK \
                          + str(round(ratio*100, 2)) + "% match")
                print("Expected: '" + expected + "'")
                print("     Got: '" + out + "'")
                if big_diff:
                    print(RED + "Big output difference detected: " + BLK \
                              + "(-5% more)")
                if num_correct < len(answers[i]):
                    print(RED + "Wrong answer detected: " + BLK + "(" \
                              + ', '.join(answers[i]) + " expected).")
            else:
                print(GRN + "Output matched (correct)!" + BLK)
            # if mismatch is really extreme, take off another 5 points
            if big_diff:
                ratio -= 0.5
            output_grade += max(0, ratio)
            
        # compute average grade of output using the sum of all comparisons
        if(len(inputs) > 0):
            output_grade /= len(inputs)
            output_grade = math.floor(output_grade*10) / 10 # round down
            answer_grade /= len(inputs)
        else:
            output_grade = 1
            answer_grade = 1
        print(div())
        print()
        print("Output grade:", output_grade)
        print("Answer grade:", answer_grade)
        print()
        
        # if no module provided, just run the program normally once
        if len(inputs) == 0:
            worked = runProg(fPath)
            if not worked:
                print(RED + "Program failed to run." + BLK)
                has_error = True

        # report stats, halt, and then proceed to cat the program
        # TODO - report grade stats
        input("Finished. Press ENTER to continue.")

        # read and print the file, and check it for main(), header, and comments
        f = open(fPath, "r")
        hasMain = False
        hasHeader = False
        atHeader = True
        hasDescription = False
        hasComments = False
        cls()
        print(div())
        for line in f:
            line = line.strip()
            print(line)
            # check for main()
            if not atHeader and not hasMain and "main" in line:
                hasMain = True
            # check for header
            if atHeader:
                if len(line) > 0 and line[0] != "#":
                    atHeader = False
                if len(line) > 0 and line[0] == "#":
                    hasHeader = True
            # check for comments
            if not atHeader and "#" in line:
                hasComments = True
            # check for program description:
            if atHeader and "description" in line.lower():
                descIndx = line.lower().find("description")
                rest = line[descIndx + 12:].strip()
                if len(rest) > 12:
                    hasDescription = True
        f.close()
        print()
        print(div())

        # go through each flag and take off points for it
        if has_error:
            issues.append("Program did not run: -" + str(HAS_ERROR))
            comments.append("Program did not run [-" + str(HAS_ERROR) + "].")
            subtractions.append(HAS_ERROR)
        if answer_grade < 1:
            answer_sub = round(WRONG_ANSWER * (1 - answer_grade))
            issues.append("Wrong answer(s): -" + str(answer_sub))
            comments.append("Wrong answer(s) [-" + str(answer_sub) + "]")
            subtractions.append(answer_sub)
        if output_grade < 1:
            output_sub = round(BAD_OUTPUT * (1 - output_grade))
            issues.append("Mismatched output: -" + str(output_sub))
            comments.append("Mismatched output [-" + str(output_sub) + "]")
            subtractions.append(output_sub)
        if not hasMain:
            issues.append("Missing main(): -" + str(NO_MAIN))
            comments.append("Missing main() [-" + str(NO_MAIN) + "].")
            subtractions.append(NO_MAIN)
        if not hasHeader:
            issues.append("Missing header: -" + str(NO_HEADER))
            comments.append("Missing header [-" + str(NO_HEADER) + "].")
            subtractions.append(NO_HEADER)
        if not hasComments:
            issues.append("No comments: -" + str(NO_COMMENTS))
            comments.append("No comments [-" + str(NO_COMMENTS) + "].")
            subtractions.append(NO_COMMENTS)
        if hasHeader and not hasDescription:
            issues.append("Missing or incomplete description: -" + str(NO_DESCRIPT))
            comments.append("Missing description [-" + str(NO_DESCRIPT) + "].")
            subtractions.append(NO_DESCRIPT)

    # Display all issues and the maximum recommended grade, and then let the
    # grader remove issues, and add or subtract points manually, or override
    # the grade as follows:
    #   Let N be a number.
    #       xN      removes issue N
    #       -N      subtracts N points
    #       +N      adds N points
    #       N       overrides the grade to N points
    #               (no input) keeps recommended grade
    showIssues(issues)
    print("Add or subtract points using +N or -N (N is the number of points).")
    recommended = computeGrade(subtractions, [])
    print(GRN + "Max grade: " + str(recommended))
    grade = input(BLU + "Grade:     " + BLK)
    additions = []
    while grade != "":
        modifications = grade.split()
        if(len(modifications) == 1 and modifications[0][0] != "+" \
                                   and modifications[0][0] != "-" \
                                   and modifications[0][0] != "x" \
                                   and modifications[0].isdigit()):
            recommended = int(modifications[0])
            break
        for mod in modifications:
            modVal = mod[1:]
            if not modVal.isdigit():
                continue
            if mod[0] == "x":
                issueIndx = int(modVal) - 1
                issues.pop(issueIndx)
                comments.pop(issueIndx)
                subtractions.pop(issueIndx)
            elif mod[0] == "+":
                cVal = int(modVal)
                additions.append(cVal)
            elif mod[0] == "-":
                cVal = int(modVal)
                additions.append(-cVal)
        showIssues(issues)
        recommended = computeGrade(subtractions, additions)
        print(GRN + "New grade: " + str(recommended))
        grade = input(BLU + "Grade:     " + BLK)
    grade = str(max(0, recommended))

    # process standard comments, and get grader append any other notes
    cmnts = ""
    for c in comments:
        cmnts += c + " "
    
    # make suggestions on frequently used comments
    suggestions = []
    for i in range(0, len(frequentComments), 2):
        freqC = frequentComments[i]
        freqV = frequentComments[i+1]
        if freqV >= COMMENT_FREQUENCY_THRESH:
            suggestions += [freqC]
    if len(suggestions) > 0:
        print()
        print("Frequent comments: use '@#' to enter them " + \
              "(# is the comment number).")
        for i in range(len(suggestions)):
            print("[" + str(i+1) + "] " + "'" + suggestions[i] + "'")
    # get grader to enter his/her own custom comments (optional)
    grader_comment = input(BLU + "Comments:  " + BLK)
    
    # if grader used the '@' to indicate frequent comments, insert them in
    parts = grader_comment.split()
    modifiedComment = False
    for part in parts:
        if len(part) > 0 and part[0] == "@":
            indx = part[1:]
            if not indx.isdigit():
                continue
            indx = int(indx) - 1
            if indx < len(suggestions):
                grader_comment = grader_comment.replace(part, suggestions[indx])
                modifiedComment = True
            else:
                grader_comment = grader_comment.replace(part, "")
    
    # add the grader's comments to the string
    cmnts += grader_comment
    
    # if user entered a comment, add it to frequent comments, or increase
    # its frequency if it already exists for future reference
    if grader_comment and not modifiedComment:
        foundMatch = False
        for i in range(0, len(frequentComments), 2):
            if strSimilarity(grader_comment, frequentComments[i]) >= 0.8 \
               and "@" not in grader_comment:
                frequentComments[i+1] += 1
                foundMatch = True
                break
        if not foundMatch and "@" not in grader_comment:
            frequentComments += [grader_comment, 1]

    print(frequentComments)
    # set up the user's grade and confirm (or redo) it if grader wants
    usrGrade = []
    usrGrade.append(student)
    usrGrade.append(grade)
    usrGrade.append(cmnts)
    print(usrGrade)
    ans = input("Done. Type 'r' to redo this grade, or 'q' to quit. ")
    quit = False
    if ans.lower() == "r":
        doGrade(student, pyFile, theirFiles, path, dueMonth, dueDay, inputs, outputs)
    elif ans.lower() == "q":
        quit = True

    # return the grade for file processing
    print(div() + "\n" + div() + "\n" + div())
    return usrGrade, quit



# Go through each student's submission and grade it, then write the grades to
# a file.
def main(assignment, pyFile, dueMonth, dueDay, module, start):
    # set up date, file path, and first person to start grading
    dueMonth = int(dueMonth)
    dueDay = int(dueDay)
    fpath = assignment
    first = True
    go = True
    if start != "":
        go = False

    # if a grading module was provided, set it up here:
    inputs = []
    outputs = []
    answers = []
    test_runs = 0
    if module != "":
        # read file and determine number of I/O test runs
        mod_fH = open(module, "r")
        lines = mod_fH.readlines()
        mod_fH.close()
        test_runs = int(lines[0][4:])
        i = 2
        for run in range(test_runs):
            inputs.append([])
            outputs.append([])
            # append each input to the inputs list for this run
            while i < len(lines) and not lines[i].startswith("OUTPUT"):
                inputs[run].append(lines[i].strip()[4:])
                i += 1
            # get the expected answers for this run
            if i < len(lines):
                ans = lines[i].split(' ')
                answerset = []
                for j in range(1, len(ans)):
                    answerset.append(ans[j].strip())
                answers.append(answerset)
            i += 1
            # get the list of full desired outputs for this run
            while i < len(lines) and not lines[i].startswith("INPUT"):
                outputs[run].append(lines[i].strip()[4:])
                i += 1
            i += 1

    # if the file is non-existent/empty or if user wants to start fresh,
    # we need to write the header of the CSV file again
    outFile = assignment.strip("/") + "_grades.csv"
    ans = "y"
    if os.path.isfile(outFile) and os.stat(outFile).st_size > 0:
        ans = "n"
        ans = input("Grade output file \"" + outFile + \
                    "\" already exists. Overwrite? [Y/n] ")
    if ans.lower() == "y":
        fH = open(outFile, "w")
        fH.write("\"Last Name\",\"First Name\",\"" + assignment + \
                 "\",\"Feedback to User\"\n")
        fH.close()

    # get a sorted list of students and iterate through them
    students = os.listdir(fpath)
    students.sort()
    freqComments = []
    numGraded = 0
    totalGrade = 0
    for student in students:
        # skip students that are before the starting point
        if not go:
            if student.startswith(start):
                go = True
            else:
                continue
        # get the student's submissions and grade the file
        files = os.listdir(fpath + "/" + student)
        usrGrade, quit = doGrade(student, pyFile, files, fpath, dueMonth, \
                                 dueDay, inputs, outputs, answers, freqComments)
        numGraded += 1
        totalGrade += int(usrGrade[1])
        
        # write the data to the output file
        studentNames = usrGrade[0].split(",")
        if len(studentNames) == 2:
            lastName, firstName = usrGrade[0].split(",")
        else:
            lastName = firstName = usrGrade[0]
        fH = open(outFile, "a")
        fH.write("\"" + lastName + "\",\"" + firstName + "\",\"" + usrGrade[1]\
            + "\",\"" + usrGrade[2].replace("\"", "\"\"") + "\"\n")
        fH.close()
        if quit:
            break
    print("Session stats:")
    print("   Number of students graded:", numGraded)
    print("   Average grade:", round(totalGrade/numGraded, 2))



# Check parameters and call main() with the appropriate values.
if __name__ == '__main__':
    if len(sys.argv) < 5:
        print("USAGE: ./grader <assignment> <.py file> <due month> <due day> [--options--]")
        print("Options:")
        print("  -m module  provide a grading module for input/output option checking")
        print("  -s start   provide the first few letters of a last name to start at")
    else:
        # check for options
        module = ""
        start = ""
        remaining_args = sys.argv[5:]
        for i in range(len(remaining_args)):
            if remaining_args[i] == "-m" and len(remaining_args) > i+1:
                module = remaining_args[i+1]
            elif remaining_args[i] == "-s" and len(remaining_args) > i+1:
                start = remaining_args[i+1]
        main(sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4], module, start)